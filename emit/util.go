package emit

import (
	"bytes"
	"errors"
	"fmt"
	"go/token"
	"io/ioutil"
	"os"
	"os/exec"
	"path"
	"regexp"
	"runtime"
	"sr/parse"
	"sr/util"
	"strings"

	"github.com/aundis/meta"
	"github.com/gogf/gf/v2/os/gfile"
)

var generatedHeader = `// ==========================================================================
// Code generated by Srpc CLI tool. DO NOT EDIT.
// ==========================================================================
`

func firstUpper(s string) string {
	if len(s) == 0 {
		return ""
	}
	return strings.ToUpper(string(s[0])) + s[1:]
}

func firstLower(s string) string {
	if len(s) == 0 {
		return ""
	}
	return strings.ToLower(string(s[0])) + s[1:]
}

func formatError(fset *token.FileSet, pos token.Pos, message string, root ...string) error {
	// emit\util.go:21:1: missing return
	p := fset.Position(pos)
	filename := p.Filename
	if len(root) > 0 {
		filename = util.TryConvRelPath(root[0], filename)
	}
	return errors.New(fmt.Sprintf("%s:%d:%d: %s", filename, p.Line, p.Column, message))
}

func listFile(dirname string, deep ...bool) ([]string, error) {
	fileInfos, err := ioutil.ReadDir(dirname)
	if err != nil {
		return nil, err
	}
	var list []string
	for _, fi := range fileInfos {
		filename := path.Join(dirname, fi.Name())
		if fi.IsDir() && len(deep) > 0 && deep[0] {
			//继续遍历fi这个目录
			files, err := listFile(filename, true)
			if err != nil {
				return nil, err
			}
			list = append(list, files...)
		} else {
			list = append(list, filename)
		}
	}
	return list, nil
}

func listDir(dirname string, deep ...bool) ([]string, error) {
	fileInfos, err := ioutil.ReadDir(dirname)
	if err != nil {
		return nil, err
	}
	var list []string
	for _, fi := range fileInfos {
		filename := path.Join(dirname, fi.Name())
		if fi.IsDir() {
			list = append(list, filename)
			if len(deep) > 0 && deep[0] {
				//继续遍历fi这个目录
				dirs, err := listFile(filename, true)
				if err != nil {
					return nil, err
				}
				list = append(list, dirs...)
			}
		}
	}
	return list, nil
}

func ensureDirExist(dir string) error {
	ok, err := fileExist(dir)
	if err != nil {
		return err
	}
	if !ok {
		err = os.MkdirAll(dir, os.ModePerm)
		if err != nil {
			return err
		}
	}
	return nil
}

func removeDirFiles(dir string) error {
	files, err := listFile(dir)
	if err != nil {
		return err
	}
	for _, v := range files {
		err := os.Remove(v)
		if err != nil {
			return err
		}
	}
	return nil
}

func fileExist(path string) (bool, error) {
	_, err := os.Stat(path)
	if err == nil {
		return true, nil
	}
	if os.IsNotExist(err) {
		return false, nil
	}
	return false, err
}

func getPackageName(expr string) string {
	index := strings.Index(expr, ".")
	return strings.ReplaceAll(expr[:index], "*", "")
}

func isUsePackage(expr string) bool {
	return strings.Contains(expr, ".") && expr[0] != '.'
}

func command(arg ...string) error {
	name := "/bin/bash"
	c := "-c"
	// 根据系统设定不同的命令name
	if runtime.GOOS == "windows" {
		name = "cmd"
		c = "/C"
	}
	arg = append([]string{c}, arg...)
	cmd := exec.Command(name, arg...)
	if err := cmd.Start(); err != nil {
		return err
	}
	return nil
}

func getProjectModuleName(dir string) (string, error) {
	fileName := path.Join(dir, "go.mod")
	if !gfile.Exists(fileName) {
		return "", errors.New("not found go.mod")
	}
	data, err := ioutil.ReadFile(fileName)
	if err != nil {
		return "", nil
	}
	index := bytes.IndexByte(data, '\n')
	if index <= 0 {
		index = len(data)
	}
	firstLine := string(data[:index])
	firstLine = strings.ReplaceAll(firstLine, "\r", "")
	firstLine = strings.ReplaceAll(firstLine, "\n", "")
	firstLine = strings.ReplaceAll(firstLine, "module ", "")
	firstLine = strings.TrimSpace(firstLine)
	if len(firstLine) == 0 {
		return "", errors.New("get project module name error")
	}
	return firstLine, nil
}

var matchNonAlphaNumeric = regexp.MustCompile(`[^a-zA-Z0-9]+`)
var matchFirstCap = regexp.MustCompile("(.)([A-Z][a-z]+)")
var matchAllCap = regexp.MustCompile("([a-z0-9])([A-Z])")

func toSnakeCase(str string) string {
	str = matchNonAlphaNumeric.ReplaceAllString(str, "_")     //非常规字符转化为 _
	snake := matchFirstCap.ReplaceAllString(str, "${1}_${2}") //拆分出连续大写
	snake = matchAllCap.ReplaceAllString(snake, "${1}_${2}")  //拆分单词
	return strings.ToLower(snake)                             //全部转小写
}

func getImportMetaExport(imeta *meta.ImportMeta) string {
	if len(imeta.Alias) > 0 {
		return imeta.Alias
	}
	return getImportPathExprot(imeta.Path)
}

func getImportPathExprot(path string) string {
	index := strings.LastIndex(path, "/") + 1
	return path[index:]
}

type refExpr struct {
	scope string
	name  string
}

func getRefExprs(v string) []refExpr {
	if strings.Index(v, ".") == -1 {
		return nil
	}

	var result []refExpr
	reg := regexp.MustCompile(`\b(\w+)\b\.\b(\w+)\b`)
	match := reg.FindAllStringSubmatch(v, -1)
	for _, v := range match {
		result = append(result, refExpr{
			scope: v[1],
			name:  v[2],
		})
	}
	return result
}

func hasGoFile(dir string) (bool, error) {
	if !gfile.Exists(dir) {
		return false, nil
	}
	files, err := listFile(dir)
	if err != nil {
		return false, err
	}
	for _, f := range files {
		if util.StringEndOf(f, ".go") {
			return true, nil
		}
	}
	return false, nil
}

func packagePathToFileName(root, pkgPath string) string {
	part := strings.Split(pkgPath, "/")
	return path.Join(root, strings.Join(part[1:], "/"))
}

func getStructInnerFields(v interface{}) []*parse.Field {
	switch n := v.(type) {
	case *parse.StructType:
		return n.Fields
	}
	return nil
}

func hasCustomerType(in string) bool {
	arr := getTypeNames(in)
	for _, v := range arr {
		if !isBuiltin(v) {
			return true
		}
	}
	return false
}

func isBuiltin(in string) bool {
	builtin := []string{
		"int",
		"int8",
		"int16",
		"int32",
		"int64",
		"uint",
		"uint8",
		"uint16",
		"uint32",
		"uint64",
		"bool",
		"interface",
		"any",
		"map",
		"byte",
		"rune",
		"string",
	}
	for _, v := range builtin {
		if v == in {
			return true
		}
	}
	return false
}

func getTypeNames(tpe string) []string {
	var results []string
	reg := regexp.MustCompile(`\b([\w\.]+)\b`)
	matchs := reg.FindAllStringSubmatch(tpe, -1)
	for _, v := range matchs {
		tar := v[1]
		if strings.Contains(tar, ".") {
			results = append(results, tar)
		} else if tar[0] >= 'A' && tar[0] <= 'Z' {
			results = append(results, tar)
		}
	}
	return results
}

func findTypeMetaForId(arr []*meta.TypeMeta, id string) *meta.TypeMeta {
	for _, v := range arr {
		if v.Id == id {
			return v
		}
	}
	return nil
}

var typeMetaIdReg = regexp.MustCompile(`\{\{(.+?)\}\}`)

func findAllTypeMetaIds(content string) []string {
	var result []string
	matchs := typeMetaIdReg.FindAllStringSubmatch(content, -1)
	for _, v := range matchs {
		result = append(result, v[1])
	}
	return result
}
