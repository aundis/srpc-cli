package util

import (
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"strings"

	"github.com/gogf/gf/v2/os/gfile"
)

var GeneratedHeader = `// ==========================================================================
// Code generated by Srpc CLI tool. DO NOT EDIT.
// ==========================================================================
`

func WriteGenerateFile(filename string, content []byte, root ...string) error {
	if gfile.Exists(filename) {
		is, err := IsGenerateFile(filename)
		if err != nil {
			return err
		}
		if !is {
			print := filename
			if len(root) > 0 {
				print = TryConvRelPath(root[0], filename)
			}
			fmt.Printf("warning: %s: no generate header ignore wirte\n", print)
			return nil
		}
	}
	return ioutil.WriteFile(filename, content, os.ModePerm)
}

func IsGenerateFile(filename string) (bool, error) {
	file, err := os.Open(filename)
	if err != nil {
		return false, err
	}
	defer file.Close()
	buffer := make([]byte, len(GeneratedHeader))
	n, err := file.ReadAt(buffer, 0)
	if err != nil && err != io.EOF {
		return false, err
	}
	if n < len(buffer) {
		return false, nil
	}
	return strings.Contains(string(buffer), `// Code generated by Srpc CLI tool. DO NOT EDIT.`), nil
}

func RemoveGenerateFiles(dir string) error {
	if !gfile.Exists(dir) {
		return nil
	}
	files, err := ListFile(dir)
	if err != nil {
		return err
	}
	for _, f := range files {
		is, err := IsGenerateFile(f)
		if err != nil {
			return err
		}
		if is {
			err = gfile.Remove(f)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func ListFile(dirname string, deep ...bool) ([]string, error) {
	fileInfos, err := ioutil.ReadDir(dirname)
	if err != nil {
		return nil, err
	}
	var list []string
	for _, fi := range fileInfos {
		filename := path.Join(dirname, fi.Name())
		if fi.IsDir() && len(deep) > 0 && deep[0] {
			//继续遍历fi这个目录
			files, err := ListFile(filename, true)
			if err != nil {
				return nil, err
			}
			list = append(list, files...)
		} else {
			list = append(list, filename)
		}
	}
	return list, nil
}

func ListDir(dirname string, deep ...bool) ([]string, error) {
	fileInfos, err := ioutil.ReadDir(dirname)
	if err != nil {
		return nil, err
	}
	var list []string
	for _, fi := range fileInfos {
		filename := path.Join(dirname, fi.Name())
		if fi.IsDir() {
			list = append(list, filename)
			if len(deep) > 0 && deep[0] {
				//继续遍历fi这个目录
				dirs, err := ListDir(filename, true)
				if err != nil {
					return nil, err
				}
				list = append(list, dirs...)
			}
		}
	}
	return list, nil
}

func TryConvRelPath(basepath, targetpath string) string {
	out, err := filepath.Rel(basepath, targetpath)
	if err != nil {
		return targetpath
	}
	return out
}
